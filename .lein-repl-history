(first (facturas "2013-5-2"))
(defn jueveses [people]
  (partition people (take 1000 (periodic/periodic-seq arbitrary-jueves (time/days 7)))))
(defn jueveses [people]
  (partition people (periodic/periodic-seq arbitrary-jueves (time/days 7) )))
(first (facturas "2013-5-2"))
(rand-nth (1 2 3 4))
(rand-nth '(1 2 3 4))
(rand-nth (1 2 3 4))
(rand-nth '(1 2 3 4))
(defn rndm [seed]
  (let [r (java.util.Random. seed)]
)
  (.nextInt r))
(defn rndm [seed]
  (let [r (java.util.Random. seed)]
  (.nextInt r))
)
(rndm 1)
(rndm 2)
(rndm 12345)
(defn rndm [seed n]
  (let [r (java.util.Random. seed)]
  (.nextInt r n))
)
(rndm 0 1)
(rndm 0 2)
(rndm 0 3)
(rndm 0 4)
(rndm 0 5)
(rndm 0 6)
(rndm 0 7)
(rndm 2 7)
(rndm 12345 7)
(rndm 12345 100)
(rndm 12345 10)
(rndm 12345 1)
(rndm 12345 12)
(rndm 123454 12)
(rndm 1234 12)
(rndm 1 1)
(rndm 2 1)
(rndm 3 1)
(rndm 4 1)
(rndm 5 1)
(rndm 6 1)
(rndm 7 1)
(rndm 1 200)
(rndm 1 4)
(rndm 2 4)
(rndm 3 4)
(rndm 4 4)
(rndm 5 4)
(rndm 7 4)
(rndm 1000 4)
(rndm 1000 1)
(rndm 1000 2)
(rndm 1000 3)
(rndm 1000 4)
(rndm 1000 5)
(rndm 1000 6)
(rndm 1000 7)
(rndm 1000 8)
(rndm 2000 8)
(rndm 3000 8)
(rndm 4000 8)
(rndm 10000 8)
(rndm 400 8)
(rndm 400 1)
(rndm 400 2)
(rndm 400 3)
(rndm 400 4)
(rndm 400 5)
(use 'clojure.contrib.probabilities.random-numbers)
(use clojure.contrib.probabilities.random-numbers)
(rndm 400 3)
(defn rndm [seed n]
  (let [r (java.util.Random. seed)]
  (.nextInt r n))
)
(defn rndm [seed n]
  (let [r (java.util.Random. seed)]
  (.nextDouble r n))
)
(rndm 1 10)
(defn rndm [seed n]
  (let [r (java.util.Random. seed)]
  (.nextInt r n))
)
(rndm 1 10)
(rndm 1 10000)
(rndm 2 10000)
(rndm 3 10000)
(rndm 4 10000)
(rndm 4 100009)
(rndm 4 1000099)
(rndm 4 100009999)
(rndm 4 10000)
(rndm 5 10000)
(use 'faltan.models)
(faltan.models/all)
(first (faltan.models/all))
(use 'faltan.models)
(first (faltan.models/all))
(faltan.models/all)
(use 'faltan.models)
(faltan.models/all)
(use 'faltan.models)
(faltan.models/all)
(use '[clojure.tools.namespace.repl :only (refresh)])
(use 'faltan.models :reload)
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(first (faltan.models/all))
(faltan.models/all)
(use 'faltan.models :reload)
(faltan.models/all)
(first (faltan.models/all))
(get (faltan.models/all) 0)
(get (faltan.models/all) 1)
(get (faltan.models/all) 2)
(faltan.models/all)
(map-indexed (fn [idx itm] [idx itm]) "foobar")
(map-indexed (fn [idx itm] [idx itm]) (faltan.models/all))
(map-indexed (fn [idx itm] {:idx itm}) (faltan.models/all))
(map-indexed (fn [idx itm] [idx itm]) (faltan.models/all))
(use 'faltan.models :reload)
(map-indexed (fn [idx itm] [idx itm]) (faltan.models/all))
(faltan.models/all)
(map-indexed 1 (faltan.models/all))
(map-indexed inc (faltan.models/all))
(map-indexed (fn [idx e] (idx e)) (faltan.models/all))
(map-indexed (fn [idx e] [idx e]) (faltan.models/all))
(map-indexed (fn [idx e] [(rndm 1 idx) e]) (faltan.models/all))
(use 'faltan.controllers)
(use 'faltan.controllers :reload)
(map-indexed (fn [idx e] [(rndm 1 idx) e]) (faltan.models/all))
(rndm 1 1)
(rndm 1 0)
(map-indexed (fn [idx e] [(rndm 1 (inc idx)) e]) (faltan.models/all))
(map-indexed (fn [idx e] [(rndm (inc idx) 1000) e]) (faltan.models/all))
(map-indexed (fn [idx e] [(rndm (inc idx) 10000) e]) (faltan.models/all))
(sort-by first (map-indexed (fn [idx e] [(rndm (inc idx) 10000) e]) (faltan.models/all)))
(defn chapita [pos] (sort-by first (map-indexed (fn [idx e] [(rndm (inc idx) (+ 10000 pos) e]) (faltan.models/all)))))
(defn chapita [pos] (sort-by first (map-indexed (fn [idx e] [(rndm (inc idx) (+ 10000 pos) e]) (faltan.models/all))))
(defn chapita [pos] (sort-by first (map-indexed (fn [idx e] [(rndm (inc idx) (+ 10000 pos)) e] (faltan.models/all)))))
(chapita 1)
(chapita 2)
(defn chapita [pos] (sort-by first (map-indexed (fn [idx e] [(rndm (inc idx) (+ 10000 pos)) e]) (faltan.models/all))))
(chapita 2)
(chapita 3)
(chapita 4)
(chapita 5)
(chapita 6)
(use 'faltan.contorllers :reload)
(use 'faltan.controllers :reload)
(faltan.controllers/ppl-sort 1 (faltan.models/all))
(faltan.controllers/ppl-sort 2 (faltan.models/all))
(faltan.controllers/ppl-sort 3 (faltan.models/all))
(faltan.controllers/ppl-sort 4 (faltan.models/all))
(faltan.controllers/ppl-sort 100 (faltan.models/all))
(count (faltan.models/all))
(count faltan.models/all)
(count (faltan.models/all))
(faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30) 5)
)
(faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5)
(use 'faltan.controllers :reload)
(faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5)
(.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) 2)
(.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-5-30"))
(.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-6-6"))
(.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-6-13"))
(faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5)
(faltan.controllers/ppl-sort 2 (faltan.models/all))
(defn ppl [n] (faltan.controllers/ppl-sort 2 (faltan.models/all)))
ppl 3
ppl 4
(defn ppl [n] (faltan.controllers/ppl-sort n (faltan.models/all)))
ppl 4
(defn ppl [n] faltan.controllers/ppl-sort n (faltan.models/all))
ppl 4
(defn ppl [n] (faltan.controllers/ppl-sort n (faltan.models/all)))
(ppl 4)
(ppl 3)
(ppl 1)
(faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5)
(def ddd (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5))
ddd
(ppl 1)
ddd
(for [x (ppl 1) y ddd] [x y])
ddd
(ppl 1)
(.indexOf ddd 1)
(.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-6-13"))
(get (ppl 1) (.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-6-13")))
(ppl 1)
(get (ppl 1) 1)
(get (ppl 1) 2)
(get (ppl 1) 0)
(nth (ppl 1) (.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-6-13")))
(nth (ppl 1) (.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-6-6")))
[2625 {:picture nil, :name "ezequiel", :id 1}]
'[2625 {:picture nil, :name "ezequiel", :id 1}]
(use 'faltan)
(use 'faltan.web)
faltan.web/-main
(faltan.web/-main)
(faltan.models/all)
(count (faltan.models/all))
(count faltan.models/all)
(count 'faltan.models/all)
(use 'faltan.web :reload)
(faltan.web/-main)
(defn choosen [date]
  (nth (get-jueveses date (count (models/all))) (.indexOf (get-jueveses date (count (models/all))) date)))
(defn choosen [date]
(ns faltan.controllers
  (:require [compojure.core :refer [defroutes GET PUT POST DELETE ANY]]
            [clojure.string :as str]
            [compojure.route :as route]
            [compojure.response :as response]
            [clostache.parser :as clostache]
            [clojure.string :refer [split]]
            [clojure.java.io :as io]
            [faltan.models :as models]
            [ring.util.response :as ring]
            [clj-time.core :as time]
            [clj-time.format :as format]
            [clj-time.periodic :as periodic]))
(def formatd (format/formatters :year-month-day))
(def arbitrary-jueves (time/date-time 2013 4 25))
(defn rndm [seed max]
  (let [r (java.util.Random. seed)]
    (.nextInt r max)))
(defn ppl-sort [pos coll]
  (sort-by first (map-indexed
    (fn [idx item] [(rndm (inc idx) (+ 10000 pos)) item]) coll)))
(defn to-date [str]
  (format/parse formatd str))
(defn from-date [date]
  (format/unparse formatd date))
(defn jueveses [cnt]
  (partition cnt (take 1000 (periodic/periodic-seq arbitrary-jueves (time/days 7)))))
(defn get-jueveses [when cnt]
  (first (filter (fn [cluster]
    (some (fn [date]
      (= when date)) cluster)) (jueveses cnt))))
(defn choosen [date]
  (nth (get-jueveses date (count (models/all))) (.indexOf (get-jueveses date (count (models/all))) date)))
(defn facturas [req]
  (response/render (choosen (to-date ((req :query-params) "date"))) req))
(defn index [req]
  (response/render (clostache/render (slurp (io/resource "templates/index.html")) (zipmap [:year :month :day :hour :minutes] (split ((req :query-params) "date") #"-"))) req))
(defroutes app
  (GET "/" [] index)
  (GET "/facturas" [] facturas)
  (route/resources "/" {:root "templates"})
  (route/not-found (slurp (io/resource "404.html"))))
(choosen (time/date-time 2013 5 30))
(defn choosen [date]
  (let [jvs (get-jueveses date (count (models/all)))]
    (nth (ppl-sort (.indexOf jvs (jueveses (count (models/all)))) (models/all)) (.indexOf date jvs))))
(choosen (time/date-time 2013 5 30))
(defn choosen [date]
    (nth (ppl-sort (.indexOf jvs (jueveses (count (models/all)))) (models/all)) (.indexOf date jvs))))
(defn choosen [date]
  (let [jvs (get-jueveses date (count (models/all)))]
    (nth (ppl-sort (.indexOf jvs (jueveses (count (models/all)))) (models/all)) (.indexOf jvs date))))
(choosen (time/date-time 2013 5 30))
(choosen (time/date-time 2013 5 23))
(choosen (time/date-time 2013 5 16))
(choosen (time/date-time 2013 7 25))
(choosen (time/date-time 2013 7 11))
(choosen (time/date-time 2013 7 4))
(ns faltan.controllers
  (:require [compojure.core :refer [defroutes GET PUT POST DELETE ANY]]
            [clojure.string :as str]
            [compojure.route :as route]
            [compojure.response :as response]
            [clostache.parser :as clostache]
            [clojure.string :refer [split]]
            [clojure.java.io :as io]
            [faltan.models :as models]
            [ring.util.response :as ring]
            [clj-time.core :as time]
            [clj-time.format :as format]
            [clj-json.core :as json]
            [clj-time.periodic :as periodic]))
(def formatd (format/formatters :year-month-day))
(def arbitrary-jueves (time/date-time 2013 4 25))
(defn json-response [data & [status]]
  {:status (or status 200)
   :headers {"Content-Type" "application/json"}
   :body (json/generate-string data)})
(defn rndm [seed max]
  (let [r (java.util.Random. seed)]
    (.nextInt r max)))
(defn ppl-sort [pos coll]
  (sort-by first (map-indexed
    (fn [idx item] [(rndm (inc idx) (+ 10000 pos)) item]) coll)))
(defn to-date [str]
  (format/parse formatd str))
(defn from-date [date]
  (format/unparse formatd date))
(defn jueveses [cnt]
  (partition cnt (take 1000 (periodic/periodic-seq arbitrary-jueves (time/days 7)))))
(defn get-jueveses [when cnt]
  (first (filter (fn [cluster]
    (some (fn [date]
      (= when date)) cluster)) (jueveses cnt))))
(defn choosen [date]
  (let [jvs (get-jueveses date (count (models/all)))]
    (nth (ppl-sort (.indexOf jvs (jueveses (count (models/all)))) (models/all)) (.indexOf jvs date))))
(defn facturas [req]
  (json-response (choosen (to-date ((req :query-params) "date")))))
(defn index [req]
  (response/render (clostache/render (slurp (io/resource "templates/index.html")) (zipmap [:year :month :day :hour :minutes] (split ((req :query-params) "date") #"-"))) req))
(defroutes app
  (GET "/" [] index)
  (GET "/facturas" [] facturas)
  (route/resources "/" {:root "templates"})
  (route/not-found (slurp (io/resource "404.html"))))
;(nth (ppl 1) (.indexOf (faltan.controllers/get-jueveses (faltan.controllers/to-date "2013-5-30") 5) (faltan.controllers/to-date "2013-6-13")))
(json-response (choosen (time/date-time 2013 7 18)))
(choosen (time/date-time 2013 7 18))
(jueveses 4)
(jueveses)
(ns faltan.controllers
  (:require [compojure.core :refer [defroutes GET PUT POST DELETE ANY]]
            [clojure.string :as str]
            [compojure.route :as route]
            [compojure.response :as response]
            [clostache.parser :as clostache]
            [clojure.string :refer [split]]
            [clojure.java.io :as io]
            [faltan.models :as models]
            [ring.util.response :as ring]
            [clj-time.core :as time]
            [clj-time.format :as format]
            [clj-json.core :as json]
            [clj-time.periodic :as periodic]))
(def formatd (format/formatters :year-month-day))
(def arbitrary-jueves (time/date-time 2013 4 25))
(def jueveses (partition (count models/all) (take 1000 (periodic/periodic-seq arbitrary-jueves (time/days 7)))))
(defn json-response [data & [status]]
  {:status (or status 200)
   :headers {"Content-Type" "application/json"}
   :body (json/generate-string data)})
(defn rndm [seed max]
  (let [r (java.util.Random. seed)]
    (.nextInt r max)))
(defn ppl-sort [pos coll]
  (sort-by first (map-indexed
    (fn [idx item] [(rndm (inc idx) (+ 10000 pos)) item]) coll)))
(defn to-date [str]
  (format/parse formatd str))
(defn from-date [date]
  (format/unparse formatd date))
(defn get-jueveses [whend]
  (first (filter (fn [cluster]
    (some (fn [date]
      (= whend date)) cluster)) jueveses)))
(defn choosen [date]
  (let [jvs (get-jueveses date (count (models/all)))]
    (nth (ppl-sort (.indexOf jvs (jueveses (count (models/all)))) (models/all)) (.indexOf jvs date))))
(defn facturas [req]
  (json-response (choosen (to-date ((req :query-params) "date")))))
(defn index [req]
  (response/render (clostache/render (slurp (io/resource "templates/index.html")) (zipmap [:year :month :day :hour :minutes] (split ((req :query-params) "date") #"-"))) req))
(defroutes app
  (GET "/" [] index)
  (GET "/facturas" [] facturas)
  (route/resources "/" {:root "templates"})
  (route/not-found (slurp (io/resource "404.html"))))
(choosen (time/date-time 2013 7 14))
(choosen (time/date-time 2013 7 14))(defn get-jueveses [whend]
  (first (filter (fn [cluster]
    (some (fn [date]
      (= whend date)) cluster)) jueveses)))
(defn choosen [date]
  (let [jvs (get-jueveses date)]
    (nth (ppl-sort (.indexOf jvs (jueveses (count (models/all)))) (models/all)) (.indexOf jvs date))))
(choosen (time/date-time 2013 7 14))
(choosen (time/date-time 2013 5 30))
(ppl-sort (.indexOf jvs (jueveses (count (models/all)))) (models/all))
(def jvs (get-jueveses (time/date-time 2013 5 30)))
(def jueveses (partition (count models/all) (take 1000 (periodic/periodic-seq arbitrary-jueves (time/days 7)))))
(ns faltan.controllers
  (:require [compojure.core :refer [defroutes GET PUT POST DELETE ANY]]
            [clojure.string :as str]
            [compojure.route :as route]
            [compojure.response :as response]
            [clostache.parser :as clostache]
            [clojure.string :refer [split]]
            [clojure.java.io :as io]
            [faltan.models :as models]
            [ring.util.response :as ring]
            [clj-time.core :as time]
            [clj-time.format :as format]
            [clj-time.periodic :as periodic]
            [clj-json.core :as json]))
(use 'clj-time.periodic)
(def jueveses (partition (count models/all) (take 1000 (periodic-seq arbitrary-jueves (time/days 7)))))
(models/all)
(count (models/all))
(def jueveses (partition (count (models/all)) (take 1000 (periodic-seq arbitrary-jueves (time/days 7)))))
(choosen (time/date-time 2013 5 30))
(jueveses)
jueveses
(defn choosen [date]
  (let [jvs (get-jueveses date)]
    (nth (ppl-sort (.indexOf jvs jueveses) (models/all)) (.indexOf jvs date))))
(choosen (time/date-time 2013 5 30))
(json-response (choosen (to-date ((req :query-params) "date"))))
(json-response (choosen (time/date-time 2013 5 30)))
(defn json-response [data & [status]]
  {:status (or status 200)
   :headers {"Content-Type" "application/json"}
   :body (json/generate-string data)})
(use 'clj-json.core :as json)
(use 'clj-json.core)
(use 'clj-json)
(use 'clj-json.core)
(require '(clj-json [core :as json]))
(ns faltan.controllers
  (:require [compojure.core :refer [defroutes GET PUT POST DELETE ANY]]
            [clojure.string :as str]
            [compojure.route :as route]
            [compojure.response :as response]
            [clostache.parser :as clostache]
            [clojure.string :refer [split]]
            [clojure.java.io :as io]
            [faltan.models :as models]
            [ring.util.response :as ring]
            [clj-time.core :as time]
            [clj-time.format :as format]
            [clj-time.periodic :as periodic]
            [clj-json.core :as json]))
(def formatd (format/formatters :year-month-day))
(def arbitrary-jueves (time/date-time 2013 4 25))
(def jueveses (partition (count (models/all)) (take 1000 (periodic/periodic-seq arbitrary-jueves (time/days 7)))))
(defn json-response [data & [status]]
  {:status (or status 200)
   :headers {"Content-Type" "application/json"}
   :body (json/generate-string data)})
(defn rndm [seed max]
  (let [r (java.util.Random. seed)]
    (.nextInt r max)))
(defn ppl-sort [pos coll]
  (sort-by first (map-indexed
    (fn [idx item] [(rndm (inc idx) (+ 10000 pos)) item]) coll)))
(defn to-date [str]
  (format/parse formatd str))
(defn from-date [date]
  (format/unparse formatd date))
(defn get-jueveses [whend]
  (first (filter (fn [cluster]
    (some (fn [date]
      (= whend date)) cluster)) jueveses)))
(defn choosen [date]
  (let [jvs (get-jueveses date)]
    (nth (ppl-sort (.indexOf jvs jueveses) (models/all)) (.indexOf jvs date))))
(defn facturas [req]
  (json-response (choosen (to-date ((req :query-params) "date")))))
(defn index [req]
  (response/render (clostache/render (slurp (io/resource "templates/index.html")) (zipmap [:year :month :day :hour :minutes] (split ((req :query-params) "date") #"-"))) req))
(defroutes app
  (GET "/" [] index)
  (GET "/facturas" [] facturas)
  (route/resources "/" {:root "templates"})
  (route/not-found (slurp (io/resource "404.html"))))
  (json-response (choosen (to-date ((req :query-params) "date")))))
(json-response (choosen (to-date ((req :query-params) "date"))))
(json-response (choosen (time/date-time 2013 5 30)))
(or (System/getenv "DATABASE_URL") db)
(let [db-host "localhost"
      db-port 5432
      db-name "facturas"]
 
  (def db {:classname "org.postgresql.Driver"
           :subprotocol "postgresql"
           :subname (str "//" db-host ":" db-port "/" db-name)
           :user "postgres"
           :password "chango"}))
(or (System/getenv "DATABASE_URL") db)
